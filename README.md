# Design Patterns

Дизайн патърните се разделят на 3 основни вида:
- Creational;
- Behavioural;
- Structural;

**Creational** - осигуряват създаването на обекти, като скриват логиката по тяхното създаване;

**Behavioural** - отговарят за комуникацията между различни видове обекти;

**Structural** - начин за създаване на по-сложни обекти, използвайки инструменти като наследяване и композиция;

## Creational Design Patterns

### Factory

### Singleton

- Осигуряваме само една инстанция на даден клас, към която има глобален достъп
- Едно място, което да достъпваме

**Пример:** База данни

```c++
static Singleton& getInstance()
{
	static Singleton instance;
	return instance;
}
```

- Плюсове:
	- Само една инстанция на даден клас;
	- Глобален достъп;
	- Lazy инициализация - обектът се създава при достъпване на обекта;

- Минуси:
	- Multithreading - трябва да подсигурим, че няма да се достигне до **race condition**;
	- Често се определя като anti-pattern;

### Builder

- В някои ситуации искаме да ни е предоставена възможност даден клас да го инициализираме постъпково;
- Решава някои проблеми на **Factory** за класове с много атрибути, от които много са **optional**;
- За да си гарантираме инициализиране на всички задължителни параметри, трябва **Builder** класът ни да има публичен конструктор
с всички задължителни атрибути като параметри, и **setter** методи за всички опционални параметри;

### Prototype

- Създаване на копие на обекти, без да се интересуваме от техния тип - **clone()**

## Behavioural Design Patterns

### Command

### Iterator

- Начин за обхождане на колекция, без да се интересуваме каква е тя;
- **Итератор** - указател към конкретен елемент;

- При имплементацията на итератор, задължително трябва да са налични следните оператори:
	- `operator++()`, `operator--()`, `operator+=()`, `operator-=()` - указателна аритметика;
	- `operator*()` - връща стойността на текущия елемент;
	- `operator->()` - връща указател на текущия елемент;
	- `operator==()`, `operator!=()` - проверки за достигане до края на колекцията;
	
- Колекциите трябва да имат следния интерфейс:
	- `begin()` - връща итератор към началото на колекцията;
	- `end()` – връща итератор към края на колекцията;
	
- Ако искаме да достъпваме елементи на произволни позиции, можем да имплементираме:
	- `operator[]()`;
	- `operator+()`;
	- `operator-()`;

**Пример:**

```c++
template <typename T>
bool search(const T* arr, const T& elem)
{
	const T* iter = arr;
	
	while (iter != nullptr)
	{
		if (*iter == elem)
		{
			return true;
		}
		
		iter++;
	}
	
	return false;
}
```

### Visitor

### Strategy

## Structural Design Patterns

### Flyweight

# SOLID

## Single Responsibility Principle

## Open-closed Principle

## Liskov Substitution Principle

## Interface Segregation Principle

## Dependency Inversion Principle
